# 典型90問
[問題](https://atcoder.jp/contests/typical90/tasks)

|難易度|問題数|期間|
|----|----|----|
|★2|10題 |2022/05/02~2022/05/03|
|★3|20題|2022/05/03~2022/05/06|
|★4|14題|2022/05/02~|
|★5|17題||
|★6|14題||
|★7|15題||
★5が500点問題相当らしいのでこれくらいは解きたい。

## 1. 羊羹切り分け
最小値の最大化は二分探索が多いらしい。

**二分探索+貪欲法**

### 学んだこと
#### 二分探索
コードの書き方を完全に忘れていた
```C++
left = -1
right = MaxSize+1
while(right-left>1){
    mid = left + (right-left)/2
    if(/*何かの処理*/){
        right = mid
    }else{
        left = mid
    }
}
return left/*最終的にleftの値が結果になる*/
```

## 4. 行列和
前処理と包除原理

### 学んだこと
#### 計算量
$10^8$に収めることを感覚として身に付けなければならない
#### 行列を出力するとき、行末尾の" "はWAの元になる
```C++
rep(i,H){
    rep(j,W){
        if(j>0)cout<<" ";//ここが重要
        cout<</*何か*/;
    }
    cout<<endl;
}
```
とする
#### 前処理
行の合計と列の合計は何度も用いるので想像できても良かったはず

## 10. 1,2クラスの区間の得点総和
**区間の総和は累積和**

解けた✌️

## 22. 直方体を全て立方体にするための必要断面数
**最大公約数はユークリッドの互除法**なおC++のライブラリ`gcd()`を使ったので関係ない模様。

解けた✌️

## 24. A,Bの数列を同じにするための試行回数
**偶奇性(パリティ)**

解けた✌️（入力の形式をミスってWA出してた）

## 27. ユーザ登録する。何日目に登録できるか
**Mapの使い方、stringの扱い**

解けた✌️

`std::set`や`std::queue`も見ておくこと。

## 33. マス目にLEDを配置するやつ
**例外（コーナーケース）に気をつけよう！**

### 学んだこと
#### 問題文をよく読む
## 55. 数列から5つを選ぶ選び方の総数
**定数倍を見積もる**

一応解けた

### 学んだこと
#### 計算量はnだけではなく定数も考慮する
今回、5回ループで計算量が$$N^5=10^10$$になると思われたが、N個から5つを選ぶ方法なので$$1/120*N^5$$となり100分の1に抑えることができる。定数倍の見積は大事。

## 61. 配列の先頭/末尾に追加する
**deque**って知ってる？

解けた✌️

`queue`, `stack`, 双方向連結リストは頻出なので覚えておくこと

## 67. 8進数を9進数にする
**N進法展開**を理解する。

+ 8->10の展開で何かしらの誤りが発生した
+ `N=0`のコーナーケースを考えていなかった

### 学んだこと
#### char->int
`数値 - '0'`これすぐ忘れる

#### N進法の方法
```C++
ll base8_to_ll(string n){
    ll ans=0,re=0,len = n.size();
    for(int i = len-1;i>=0;i--){
        ans += (n[i]-'0')*pow(8,re);
        re++;
    }
    return ans;
}
```
これだと何故かうまくいかないケースが発生するため下記のように書くと通った。
```C++
ll base8_to_ll(string n){
    ll ans=0,len = n.size();
    for(int i = 0;i<len;i++){
        ans = ans * 8 + ll(n[i]-'0');
    }
    return ans;
}
```
## 78. グラフ問題
**グラフの基本**（グラフ使わなかったけど）

解けた✌️
### 学んだこと
#### 隣接リストの作り方
```C++
vector<vector<int> > G(N);
G[b].push_back(a);
```

---

## 2. 辞書順に列挙
**小さい制約は全探索を考えよう**（bit DPもできるらしい）
### 学んだこと
#### bit全探索
2^20はほぼ10^6なので問題ない
```C++
rep(i,pow(2,N)){
    string s = ll_to_s(i);
    /*何らかの処理*/
}
```
#### 典型知識（正しいカッコ列の条件）
+ `(`,`)`が同数である
+ 全ての添字において、添字`i`の地点で`(`の数>=`)`の数 となる
## 7. 配列と照合して差の最小値を求める
**要素の検索は二分探索**

二分探索くさいなと思ったが、全探索の方法を模索して原因不明のWA(TLEも1つ)を頻発して解答を見た
### 学んだこと
#### ソートと最小値検索
```C++
decltype(A)::iterator it = lower_bound(all(A),B);//内部で二分探索が動いている
ll pos = distance(A.begin(),it);
/* 
*it で値を抽出できる
pos で位置を取得できる
*/
```
## 14. 7.をより拘束した問題（全ての箱に一つずつ入れたときの合計最小値）✌️
**ソートして貪欲法**

数学的証明としては、導線が交差しているところをswapして解消すればそれが最小経路となる~みたいな感じ。
## 16. A,B,C円硬貨でN円を支払うための最小枚数
合計枚数が9999枚以下->**工夫した全探索**
### 学んだこと
+ 問題数をこなして経験値を稼ぐことの大切さ
    + これって蟻本そのままでは？
+ 大小比較で`min()`を使えるの忘れていた
## 18. xyz空間系問題（円運動付）✌️
中高の数学力っぽい

**三角関数を使いこなそう**
### 学んだこと
+ `atan2(y,x)`でラジアンを取得する
    + `(角度)=180/pi*radian`
+ 小数点以下桁数の調整
    + `cout<< fixed << setprecision(12) <<ans<<endl;`
## 20. log_2 a<blog_2 c ?✌️
高校数学
### 学んだこと
+ `pow()`ではなく`powl()`を使わないとWAになる場合がある
    + 今回は特に数が大きく10^18になるため明示的に使わないと危ない
## 32. 駅伝（並びに制約がある）
**小さい制約は順列全探索**

可変長ベクトルの長さをグローバル関数で指定してしまいsegmentation faultしまくってた
### 学んだこと
#### 順列全探索
`next_permutation()`：与えられた時点の`[first,last)`の範囲を起点の順列として、辞書順による次の順列を生成する
```C++
do{
    /**/
}while(next_permutation(all(v)));
```
#### vectorの各要素でfor文を回す
```C++
for(auto x:V){
    /**/
}
```
## 38. A,Bの最小公倍数を調べる 10^18以上の場合はlargeと出力する✌️
**オーバーフローに注意**
### 学んだこと
+ `lcm(a,b)=a*b/gcd(a,b)`
+ `r<=floor(10^18/a)`⇔`a*r<=10^18`という関係を利用する
## 44. 数列のshift & Swap✌️
`deque`を使う問題かと思った

想定解答としては見掛け上の変化を記録して解くらしい
```C++
x=(x-shift+n)%n; y=(y-shift+n)%n;//shiftはシフトカウンタ
if(a==2)shift=(shift+1)%n;
```
## 46. 3つ数列から数字を選んで46nにする選び方の総数✌️
## 48. 部分点ありの問題で獲得できる最大得点✌️
2配列を同期させてソートしたい->と思ったらただの配列ソートでしたガハハ！（内容はソートを使った貪欲法）

## 50. N段の階段を1orL段で登るときの移動方法は何通り？
BADcode
```C++
ll N,L;
ll Q = 1000000000+7;
int main() {
    ll cnt =1;
    cin>>N>>L;
    ll R = N/L;
    for(ll i = 1;i<=R;i++){
        ll p = N - L*i;
        ll q = i;
        if(p<q)swap(p,q);
        ll n = q+p;
        ll tmp = n!/(p!*q!);//数値が爆発してうまくいかない
        cnt = (cnt+tmp)%Q;
    }
    cout<<cnt<<endl;
    return 0;
}
```
**漸化式を立ててDP**
### 学んだこと
+ 漸化式を立てて配列を使ってDPすること（全体計算量がO(n)）
## 52. ダイスの出目の結果(6^N通り)の総和✌️
**因数分解しよう**（sum-product）

因数分解のテクニックは約数の個数や約数の総和の公式にも応用できる
## 64. 地殻変動による不便さの算出
**階差を考えよう**
### 学んだこと
+ 階差を考えるときの配列は`0`スタートじゃなくて`1`スタートの方が何かと都合がいい
## 69. 一列に並んだブロックの色の塗り方問題✌️
**a^b mod mは繰り返し二乗法**<-倍速powで解いちゃった(想定ソースコード見たら同じことやってた)
### 学んだこと
#### [繰り返し二乗法](https://twitter.com/e869120/status/1405659999179722754/photo/1)
```C++
ll powQ(ll x, ll n){
    if(n==0) return 1;
    if(n%2==0)return powQ(x*x%Q,n/2);
    else return x*powQ(x*x%Q,n/2)%Q;
}
```
## 75. 素数 or notを判定する + 非素数を素数に（最小手数で）分解する　✌️
[**O(√N)での素因数分解**](https://qiita.com/drken/items/a14e9af0ca2d857dad23#2-2-%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A)
### 学んだこと
#### 素数判定機, 素因数分解機の作り方
RSA暗号の部分で触ったところの再確認
```C++
ll primeFactrize(ll n){
    /*素因数分解*/
    vector<ll> p;
    ll rem = n;
    for(ll i=2;i*i<=n;++i){//O(√N)
        if(rem%i!=0)continue;
        while(rem%i==0){
            rem /=i;
            p.push_back(i);
        }
    }
    if(rem!=1)p.push_back(rem);
    return outp;
}
```
## 76. ケーキカット（円環の部分和）
N^2でTLEになった。
**円環を列にして二倍にする**->累積和で二分探索->O(NlogN)
## 79. 2つの二次元配列を一致させる手数
行う操作の組み合わせが同じである場合、**操作順序によらない**。よって左上から順に操作を行えばよい（10^4なので十分計算できる）
+ 賢い方法を探しがちだがちゃんと計算量を考えよう
## 82. 数字を羅列してその文字数を数える
オーバーフローで計算がうまくいかない。->考え方は合ってた

[解説](https://twitter.com/e869120/status/1411094412319330305)
[想定コード](https://github.com/E869120/kyopro_educational_90/blob/main/sol/082a.cpp)

**部分問題に分ける/数列の公式**
## 84. `o`,`x`から構成される文字列が与えられる。条件に当てはまる部分文字列はいくつあるか✌️
O(N^2)->O(NlogN)にしてAC。模範解答（2種類用意されている）ではなかった。
### 学んだこと
#### ランレングス圧縮
`oooooxxxxooo`は`5,4,3`のように圧縮可能。区間`[l,r]`が一種類のシンボルしか含まないということはこの圧縮したグループの1区間にしか含まれていないことを意味する。したがって余事象をとれば算出できる。計算量O(N)
#### 累積的に計算しよう
---
## 3. 道を1本足して最大閉路を作成する
模範コードはダイクストラ法ではなかった。
### 学んだこと
#### **木の直径は最短距離計算を2回やる**
#### 幅優先探索の実装
```C++
void calc(ll a){
    rep(i,N+1)d[i] = -1;//初期化
    queue<ll> q;//queue
    q.push(a);
    d[a] = 0;
    while(!q.empty()){
        ll pos = q.front();
        q.pop();
        for(auto to:E[pos]){
            if(d[to]== -1){
                d[to] = d[pos]+1;
                q.push(to);
        }
    }
}
```
## 8. 文字列から部分文字列群を取り出しそれを結合してある語句を作れるか？それは何通りできるか？
**状態DPによる高速化**<-今回はO(8*N)で解ける

位置と現在の状態を保持するDPで解ける問題は多い<-耳DPと呼ばれる

解説見ながら実装したので似たような問題をもう少し解きたい
## 12. 2次元平面を赤に塗る、赤色を伝って地点A->地点Bに移動できるか判定
幅全探索だとO(QHW)=10^12でTLEとなる。
**連結判定はUnion-find木**->計算量は(HW+Qα(HW))となる。
#### Union-find
実装が怠い。
```C++
class UnionFind {
public:
	vector<int> par;

	void init(int sz) {
		par.resize(sz, -1);
	}
	int root(int pos) {
		if (par[pos] == -1) return pos;
		par[pos] = root(par[pos]);
		return par[pos];
	}
	void unite(int u, int v) {
		u = root(u); v = root(v);
		if (u == v) return;
		par[u] = v;
	}
	bool same(int u, int v) {
		if (root(u) == root(v)) return true;
		return false;
	}
};
```
#### 二次元配列を木構造に取り込む
`pair<ll,ll>`を使うよりハッシュ化した方が楽（`hash=(x-1)*X+(y-1);`）
## 26. 木構造から隣接しないように頂点をN/2取り出す
また木構造の問題。何もわからん<-二部グラフくらい思いついてもよかった

**二部グラフの性質を使おう**
### 二部グラフの性質
+ 奇数長の閉路を含まない
+ 最大マッチングが多項式時間で計算できる
+ 深さ優先探索で彩色する
```C++
void dfs(ll pos, ll cur){//深さ優先探索
    colors[pos] = cur;
    for(auto i:V[pos]){
        if(colors[i]==-1) dfs(i,1-cur);
    }
}
```
### 無駄に変な条件式で出力するのではなく、**出力する配列はちゃんと定義すること**
よく分からんREやWAが発生するので
## 28. N枚の紙の重なっている部分の面積を重なっている枚数ごとに計算する
**領域加算は二次元いもす法**->O(N+HW)
### いもす法
in時に+1, out時に-1した後、その累積和を取るというもの
### 配列の大きさは大きめに確保したほうがいい
過不足ない大きさの配列を用意したら、用意した気になっただけの時がある。
## 34. N長の数列で、K種類以下の数字から構成される最長の部分列は？
しゃくとり法なのは容易に予想できたが実装できなかった……。類題を解きたい。
### しゃくとり法
+ mapを使う
```C++
ll r=1,cnt=0;
rrep(i,N){//左端を司る
    while(r<=N){//右端を司る
        if(Map[a[r]]==0 && cnt==K)break;//参照位置の出現数が0(新しい数字)、かつ、部分列出現が既にK種類
        if(Map[a[r]]==0)cnt++;          //参照位置の出現数が0(新しい数字)
        Map[a[r]] +=1;
        r++;
    }
    maxlen = max(maxlen,r-i);
    if(Map[a[i]]==1)cnt--;
    Map[a[i]] -= 1;
}
```
左端のループの中に右端のループを入れ込む感じで実装する
## 42. Xが9の倍数かつ、Xの格桁がKとなるようなXの数（ただしXは0を含まない）
数学力っぽい。DPっぽい雰囲気は感じたが漸化式を立てられなかった
### 動的計画法
DP\[各桁の数字の和\]=通り数、となる
### 倍数の性質
8の倍数：下3桁が8の倍数
11の倍数：(奇数番目の桁の合計)-(偶数番目の桁の合計)=11の倍数
## 58. オリジナル電卓✌️
コードが汚くてコーナーケースの例外処理をいろいろ施した。解けたのでヨシ。
[模範解答](https://github.com/E869120/kyopro_educational_90/blob/main/sol/058.cpp)
### 周期性を考える
## 63. グリッドから"良い部分グリッド"の最大面積を求める

